# Introducing LITMUS

*All proofs emitted by a cryptographically secured system must be verifiable by an independent observer with reasonable cost in both space & time.*

## Introduction

What is truth and what is a lie ?  Whilst the question is irrelevant for systems predicated upon coercion, it is essential for systems predicated upon cryptography, e.g. distributed ledgers.  The cyber-security maxim "trust but verify" underlines the fact that system verification is as important as system execution.  Only by the former can the latter be trusted. 

Therefore all systems claiming to be cryptographically secure must provide a clear set of verification instructions to be executed whenever the system transitions from one state to another, e.g. whenever a block is produced.  Verification is seen as a dynamic process shadowing the evolution of system state in realtime.

But who is incentivised to pay the cost of verification ?  Within a blockchain setting, whereas validator nodes pay the cost they are subsequently reimbursed by the protocol's reward scheme.  Other system actors, especially the weakly incentivised, tend to simply trust the integrity of validators to foot the verification bill.

But what happens if a validator is byzantine (intenionally or unintentionally) ?  Whilst byzantine nodes typcially need to collude in order to compromise the protocol, in isolation a node can trivially spoof software agents requesting access to it's on-chain data.  Such spoofing can pollute the wider eco-system of upstream middleware services.  

Within a mature blockchain ecosystem all entities should be able to trustlessly interact with the blockchain.  It ought be relatively easy for software agents such as a wallet, an exchange's backend, a system test platform, to programmatically intereact with verified data and receive realtime alerts of verification success & failures.

As of the time of writing, within the context of the Casper blockchain, it is clear that few if any entities are independently verifying system state.  Project *LITMUS* is an attempt to rectify this situation.  Whereas phase one of the LITMUS project will be predicated upon a fairly traditional verification strategy, phase two will leverage more recent advances in cryptography (e.g. zero-knowledge).

This article is the first in an extended series detailing the set of requirements for LITMUS, the design options, and the various implementations (as they emerge).  It's time for Casper to pass the LITMUS test.

## Proof Types

All proofs emitted by a cryptographically secured system must be verifiable by an independent observer with reasonable cost in both space & time.  To understand such costs it is useful to review the type of cryptographic proofs to be verified.  

### Hash

A hash is a cryptographic fingerprint over a binary representation of some data, e.g. a block.  A good hashing algorithm exhibits properties such as irreversibilty and collision resistance.  The primary hashing algorithm utilised by the Casper platform is *blake2b*.

To verify a given hash, one must have access to the original data plus the binary codec used to compute the data's binary representation.  Utilizing the codec, one serializes the data to it's binary representation, and then recomputes it's hash by executing the hashing algorithm.  If the recomputed and original hashes are not equal, it is highly likely that the data has been tampered with and a security breach has occurred.  Note that a false negative may be reported if either the codec or hashing algorithm implementation is faulty.

Hash computation and verification is the work horse of any blockchain system.  Not only is all data hashed, e.g. transactions and blocks, but every state transtion results in the computation of an innumerable number of hashes over state deltas.  

### Signature

A signature is cryptographic evidence of a commitment by some party to the binary representation of some data.  The party initiates the signature procecss by selecting a signature algorithm and generating an assymmetric key pair, i.e. a *secret* signing key and a *public* verification key.  The Casper blockchain account space is associated with assymetric key pairs generated by one of the following ECC algoritums: ed25519 or secp256k1.  To obtain the signature the party passes the signing key and the binary representation of the data to the algorithm.

To verify a given signature requires access to the verification key associated with the signing key used to emit the signature.  The signature algorithm will error if the signature was not generated with the private key associated with the verification key.  If a signature is invalid then it is highly likely that public key is being spoofed and that a security breach has occurred.  Note that a false negative may be reported if the signing algorithm implementation is faulty.

Signature computation and verification is fundamental to encoding intents and signalling commitments.  All transactions must be signed by users.  All messages exchanged between nodes are signed.  

### Merkle

System state can be concisely encoded using a cryptographic data structure known as a Merkle Trie.  Within the context of a blockchain, the existing state of the system and the set of transactions to be applied, is passed into an execution engine.  

To verify a merkle proof requires ...

If a merkle proof is invalid then it is highly likely that the data under the merkle trie is being spoofed, and thus a security breach has occurred ...

### Zero Knowledge

**TODO**

## Summary

The state of all systems ought to be independently verified.  In cases whereby a system is being secured via cryptography, one pathway to verification is to ensure that all cryptographic proofs emitted by that system are verified in a timely fashion.  In this introductory article we detailed the set of cryptographic proofs currently emitted by the Casper platform, we also touched upon potential future proof types as the platform evolves.

Whilst verifying cryptographic proofs is a necessary pre-requisite, in and of itself it is insufficient because no proof is emitted in a business logic vacumm.  Therefore the next stage of verification involves assserting system business rules, e.g. were block finality signatures correctly computed ?  The next article in this series will specify sets of verification business rules pertinent to the Casper platform, another step towards passing the LITMUS test.

## Acknowledgements

This article was written by Mark Greenslade and Matthew Doty.  They received significant inputs and feed from Pavel Burylichev of the Casper R&D team and Ian Mills of Stormeye (Casper Java SDK maintainers).
