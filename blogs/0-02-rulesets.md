# LITMUS Rule Sets

*The execution of all business logic executed by system must be verifiable by an independent observer with reasonable cost in both space & time.*

## Introduction

Project LITMUS is an endeavour to incubate a set of software agents able to trustlessly interact with the Casper platform.  This article is the second in an extended series detailing the set of requirements for LITMUS, the design options, and the various implementations (as they emerge).  

As stated in the first article a typical blockchain system emits cryptographic proofs of 

## Proof Types

All proofs emitted by a cryptographically secured system must be verifiable by an independent observer with reasonable cost in both space & time.  To understand such costs it is useful to review the type of cryptographic proofs to be verified.  

### Hash

A hash is a cryptographic fingerprint over a binary representation of some data, e.g. a block.  A good hashing algorithm exhibits properties such as irreversibilty and collision resistance.  The primary hashing algorithm utilised by the Casper platform is *blake2b*.

To verify a given hash, one must have access to the original data plus the binary codec used to compute the data's binary representation.  Utilizing the codec, one serializes the data to it's binary representation, and then recomputes it's hash by executing the hashing algorithm.  If the recomputed and original hashes are not equal, it is highly likely that the data has been tampered with and a security breach has occurred.  Note that a false negative may be reported if either the codec or hashing algorithm implementation is faulty.

Hash computation and verification is the work horse of any blockchain system.  Not only is all data hashed, e.g. transactions and blocks, but every state transtion results in the computation of an innumerable number of hashes over state deltas.  

### Signature

A signature is cryptographic evidence of a commitment by some party to the binary representation of some data.  The party initiates the signature procecss by selecting a signature algorithm and generating an assymmetric key pair, i.e. a *secret* signing key and a *public* verification key.  The Casper blockchain account space is associated with assymetric key pairs generated by one of the following ECC algoritums: ed25519 or secp256k1.  To obtain the signature the party passes the signing key and the binary representation of the data to the algorithm.

To verify a given signature requires access to the verification key associated with the signing key used to emit the signature.  The signature algorithm will error if the signature was not generated with the private key associated with the verification key.  If a signature is invalid then it is highly likely that public key is being spoofed and that a security breach has occurred.  Note that a false negative may be reported if the signing algorithm implementation is faulty.

Signature computation and verification is fundamental to encoding intents and signalling commitments.  All transactions must be signed by users.  All messages exchanged between nodes are signed.  

### Merkle

System state comes in two flavours, namely mutable or immutable.  For example, account information (e.g. balance) is mutable, it changes in response to user actions such as transfers.  On the other hand, transactions & blocks are immutable, once instantiated they never change.  System state persistence should be optimised accordingly.

A Merkle Trie is a tree-like cryptographic data structure well suited to recording **immutable** data sets.  In such a graph each leaf node represents a **hash** over the binary representation of some data (e.g. a transaction).  The root node of such a graph acts as an immutable commitment to the data set thus encapasulated by the graph.






Within the context of a blockchain, the existing state of the system and the set of transactions to be applied, is passed into an execution engine.  

To verify a merkle proof requires ...

If a merkle proof is invalid then it is highly likely that the data under the merkle trie is being spoofed, and thus a security breach has occurred ...

### Proof Sets

Broadly speaking proof sets overlay system inputs & state transitions.  In the context of a blockchain, inputs are transactions and state transitions are the side effects of executing blocks.  The set of proofs generated by an instance of the Casper blockchain relate to input data (transactions), state (merkle trie) and state transitions (blocks).

### Block Data

A subset of chain operators, having sucessfully participated in a validator auction, are designated by the protocol to act as block producers during a particular era of consensus.  Each such era is demarcated into a set of rounds, within each round the protocol grants a single validator authorisation to produce a block.

When authorized, the validator constructs a block by selecting a set of transactions from it's local queue.  Once constrcutred the validator signs over the block hash.  The block plus signature is gossipped to the other validators.  If they deem the block to be valid then the other validators must gossip their own signatures thereby signalling commitment to the block.  A validator node that has collated a sufficient weight of block signatures can proceed to execute the block.

To fully verify a block one also requires access to it's verified parent plus the last verified block in the previous era.  Given such data one applies the following rules:

#### BL-000: Verify block was successfully downloaded.

Issue a `get-block` query to a a node.  Invalid if HTTP 404.  

#### BL-001: Verify block hash of parent.

Compare the block's *parent_hash* against the hash of it's parent block.  Invalid if hashes are not equal.

#### BL-002: Verify block hash.

Recompute block hash from original block payload.  Invalid if original and recomputed hashes are not equal.

#### BL-003: Verify proposer is a signatory.

Check that block proposer, as detailed in the block body, is amongst set of block signatories.  Invalid if not a signaory.

#### BL-004: Verify block signatories are era signatories.

Check that each block signatory is a member of the era signatory set.  Invalid if a block signatory is not an era signatory.

#### BL-004: Verify block signatures.

Recompute digest for block finality, and verify each block signature.  Invalid if any signature is invalid.

Note: the digest for block finality is computed by appending the binary representation of the CL U64 value of the current era id to the block hash.

#### BL-006: Verify block signature weight.

Verify that the cumulative weight of valid block signatures exceeds honest minority threshold.  Invalid if signature weight is insufficient (i.e. < 1/3 total signature weight).

### Transaction Data

To be accepted for processing each transaction must be digitally signed.  The Casper platform natively supports a form of weighted multi-sig, thus a transaction maybe associated with upto 1024 signatures.  Each signature must conform to one of two supported ECC signature schemes, i.e. secp256k1 or ed25519.  Each signatory signs over the so-called transaction hash, i.e. a cryptographic fingerprint of the transaction payload.  

To verify a transaction apply the following rules:

#### TX-001: Validate transaction hash

Recompute transaction hash from original transaction payload.  Invalid if hashes are not equal.

#### TX-002: Validate transaction signatures

Iterate set of transaction signatures and verify each signature.  Invalid if any signature is invalid.

### Transaction Execution

To be accepted for processing each transaction must be digitally signed.  The Casper platform natively supports a form of weighted multi-sig, thus a transaction maybe associated with upto 1024 signatures.  Each signature must conform to one of two supported ECC signature schemes, i.e. secp256k1 or ed25519.  Each signatory signs over the so-called transaction hash, i.e. a cryptographic fingerprint of the transaction payload.  To verify transaction data apply the following rules:

